/*
moon-vault-api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package moonsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type OnramperAPI interface {

	/*
	OnRamperCheckout Method for OnRamperCheckout

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName
	@return OnramperAPIOnRamperCheckoutRequest
	*/
	OnRamperCheckout(ctx context.Context, accountName string) OnramperAPIOnRamperCheckoutRequest

	// OnRamperCheckoutExecute executes the request
	//  @return interface{}
	OnRamperCheckoutExecute(r OnramperAPIOnRamperCheckoutRequest) (interface{}, *http.Response, error)

	/*
	OnRamperGetQuotesBuy Method for OnRamperGetQuotesBuy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetQuotesBuyRequest
	*/
	OnRamperGetQuotesBuy(ctx context.Context) OnramperAPIOnRamperGetQuotesBuyRequest

	// OnRamperGetQuotesBuyExecute executes the request
	//  @return []Quote
	OnRamperGetQuotesBuyExecute(r OnramperAPIOnRamperGetQuotesBuyRequest) ([]Quote, *http.Response, error)

	/*
	OnRamperGetQuotesSell Method for OnRamperGetQuotesSell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetQuotesSellRequest
	*/
	OnRamperGetQuotesSell(ctx context.Context) OnramperAPIOnRamperGetQuotesSellRequest

	// OnRamperGetQuotesSellExecute executes the request
	//  @return []SellQuote
	OnRamperGetQuotesSellExecute(r OnramperAPIOnRamperGetQuotesSellRequest) ([]SellQuote, *http.Response, error)

	/*
	OnRamperGetSupportedAssets Method for OnRamperGetSupportedAssets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetSupportedAssetsRequest
	*/
	OnRamperGetSupportedAssets(ctx context.Context) OnramperAPIOnRamperGetSupportedAssetsRequest

	// OnRamperGetSupportedAssetsExecute executes the request
	//  @return SupportedAssetResponse
	OnRamperGetSupportedAssetsExecute(r OnramperAPIOnRamperGetSupportedAssetsRequest) (*SupportedAssetResponse, *http.Response, error)

	/*
	OnRamperGetSupportedCurrencies Method for OnRamperGetSupportedCurrencies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetSupportedCurrenciesRequest
	*/
	OnRamperGetSupportedCurrencies(ctx context.Context) OnramperAPIOnRamperGetSupportedCurrenciesRequest

	// OnRamperGetSupportedCurrenciesExecute executes the request
	//  @return SupportedCurrenciesResponse
	OnRamperGetSupportedCurrenciesExecute(r OnramperAPIOnRamperGetSupportedCurrenciesRequest) (*SupportedCurrenciesResponse, *http.Response, error)

	/*
	OnRamperGetSupportedDefaultsAll Method for OnRamperGetSupportedDefaultsAll

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetSupportedDefaultsAllRequest
	*/
	OnRamperGetSupportedDefaultsAll(ctx context.Context) OnramperAPIOnRamperGetSupportedDefaultsAllRequest

	// OnRamperGetSupportedDefaultsAllExecute executes the request
	//  @return SupportedDefaultResponse
	OnRamperGetSupportedDefaultsAllExecute(r OnramperAPIOnRamperGetSupportedDefaultsAllRequest) (*SupportedDefaultResponse, *http.Response, error)

	/*
	OnRamperGetSupportedOnRampsAll Method for OnRamperGetSupportedOnRampsAll

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetSupportedOnRampsAllRequest
	*/
	OnRamperGetSupportedOnRampsAll(ctx context.Context) OnramperAPIOnRamperGetSupportedOnRampsAllRequest

	// OnRamperGetSupportedOnRampsAllExecute executes the request
	//  @return GetSupportedOnRampsResponse
	OnRamperGetSupportedOnRampsAllExecute(r OnramperAPIOnRamperGetSupportedOnRampsAllRequest) (*GetSupportedOnRampsResponse, *http.Response, error)

	/*
	OnRamperGetSupportedPaymentTypes Method for OnRamperGetSupportedPaymentTypes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetSupportedPaymentTypesRequest
	*/
	OnRamperGetSupportedPaymentTypes(ctx context.Context) OnramperAPIOnRamperGetSupportedPaymentTypesRequest

	// OnRamperGetSupportedPaymentTypesExecute executes the request
	//  @return SupportedPaymentTypesCurrencyResponse
	OnRamperGetSupportedPaymentTypesExecute(r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) (*SupportedPaymentTypesCurrencyResponse, *http.Response, error)

	/*
	OnRamperGetSupportedPaymentTypesFiat Method for OnRamperGetSupportedPaymentTypesFiat

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest
	*/
	OnRamperGetSupportedPaymentTypesFiat(ctx context.Context) OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest

	// OnRamperGetSupportedPaymentTypesFiatExecute executes the request
	//  @return SupportedPaymentTypesCurrencyResponse
	OnRamperGetSupportedPaymentTypesFiatExecute(r OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest) (*SupportedPaymentTypesCurrencyResponse, *http.Response, error)
}

// OnramperAPIService OnramperAPI service
type OnramperAPIService service

type OnramperAPIOnRamperCheckoutRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	accountName string
	transactionInput *TransactionInput
}

func (r OnramperAPIOnRamperCheckoutRequest) Authorization(authorization string) OnramperAPIOnRamperCheckoutRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperCheckoutRequest) TransactionInput(transactionInput TransactionInput) OnramperAPIOnRamperCheckoutRequest {
	r.transactionInput = &transactionInput
	return r
}

func (r OnramperAPIOnRamperCheckoutRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.OnRamperCheckoutExecute(r)
}

/*
OnRamperCheckout Method for OnRamperCheckout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName
 @return OnramperAPIOnRamperCheckoutRequest
*/
func (a *OnramperAPIService) OnRamperCheckout(ctx context.Context, accountName string) OnramperAPIOnRamperCheckoutRequest {
	return OnramperAPIOnRamperCheckoutRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return interface{}
func (a *OnramperAPIService) OnRamperCheckoutExecute(r OnramperAPIOnRamperCheckoutRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperCheckout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/fund/${accountName}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountName"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.transactionInput == nil {
		return localVarReturnValue, nil, reportError("transactionInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	// body params
	localVarPostBody = r.transactionInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetQuotesBuyRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	fiat *string
	crypto *string
	amount *float64
	paymentMethod *string
	uuid *string
	clientName *string
	country *string
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Authorization(authorization string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Fiat(fiat string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.fiat = &fiat
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Crypto(crypto string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.crypto = &crypto
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Amount(amount float64) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.amount = &amount
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) PaymentMethod(paymentMethod string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.paymentMethod = &paymentMethod
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Uuid(uuid string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.uuid = &uuid
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) ClientName(clientName string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.clientName = &clientName
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Country(country string) OnramperAPIOnRamperGetQuotesBuyRequest {
	r.country = &country
	return r
}

func (r OnramperAPIOnRamperGetQuotesBuyRequest) Execute() ([]Quote, *http.Response, error) {
	return r.ApiService.OnRamperGetQuotesBuyExecute(r)
}

/*
OnRamperGetQuotesBuy Method for OnRamperGetQuotesBuy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetQuotesBuyRequest
*/
func (a *OnramperAPIService) OnRamperGetQuotesBuy(ctx context.Context) OnramperAPIOnRamperGetQuotesBuyRequest {
	return OnramperAPIOnRamperGetQuotesBuyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Quote
func (a *OnramperAPIService) OnRamperGetQuotesBuyExecute(r OnramperAPIOnRamperGetQuotesBuyRequest) ([]Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetQuotesBuy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/quotes/buy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.fiat == nil {
		return localVarReturnValue, nil, reportError("fiat is required and must be specified")
	}
	if r.crypto == nil {
		return localVarReturnValue, nil, reportError("crypto is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fiat", r.fiat, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "crypto", r.crypto, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	} else {
		var defaultValue string = "creditcard"
		r.paymentMethod = &defaultValue
	}
	if r.uuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "")
	} else {
		var defaultValue string = ""
		r.uuid = &defaultValue
	}
	if r.clientName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientName", r.clientName, "")
	} else {
		var defaultValue string = ""
		r.clientName = &defaultValue
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	} else {
		var defaultValue string = ""
		r.country = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetQuotesSellRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	fiat *string
	crypto *string
	amount *float64
	paymentMethod *string
	uuid *string
	clientName *string
	country *string
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Authorization(authorization string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Fiat(fiat string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.fiat = &fiat
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Crypto(crypto string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.crypto = &crypto
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Amount(amount float64) OnramperAPIOnRamperGetQuotesSellRequest {
	r.amount = &amount
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) PaymentMethod(paymentMethod string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.paymentMethod = &paymentMethod
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Uuid(uuid string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.uuid = &uuid
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) ClientName(clientName string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.clientName = &clientName
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Country(country string) OnramperAPIOnRamperGetQuotesSellRequest {
	r.country = &country
	return r
}

func (r OnramperAPIOnRamperGetQuotesSellRequest) Execute() ([]SellQuote, *http.Response, error) {
	return r.ApiService.OnRamperGetQuotesSellExecute(r)
}

/*
OnRamperGetQuotesSell Method for OnRamperGetQuotesSell

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetQuotesSellRequest
*/
func (a *OnramperAPIService) OnRamperGetQuotesSell(ctx context.Context) OnramperAPIOnRamperGetQuotesSellRequest {
	return OnramperAPIOnRamperGetQuotesSellRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SellQuote
func (a *OnramperAPIService) OnRamperGetQuotesSellExecute(r OnramperAPIOnRamperGetQuotesSellRequest) ([]SellQuote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SellQuote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetQuotesSell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/quotes/sell"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.fiat == nil {
		return localVarReturnValue, nil, reportError("fiat is required and must be specified")
	}
	if r.crypto == nil {
		return localVarReturnValue, nil, reportError("crypto is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fiat", r.fiat, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "crypto", r.crypto, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "")
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethod", r.paymentMethod, "")
	} else {
		var defaultValue string = "creditcard"
		r.paymentMethod = &defaultValue
	}
	if r.uuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "")
	} else {
		var defaultValue string = ""
		r.uuid = &defaultValue
	}
	if r.clientName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientName", r.clientName, "")
	} else {
		var defaultValue string = ""
		r.clientName = &defaultValue
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	} else {
		var defaultValue string = ""
		r.country = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetSupportedAssetsRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	source *string
	country *string
}

func (r OnramperAPIOnRamperGetSupportedAssetsRequest) Authorization(authorization string) OnramperAPIOnRamperGetSupportedAssetsRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetSupportedAssetsRequest) Source(source string) OnramperAPIOnRamperGetSupportedAssetsRequest {
	r.source = &source
	return r
}

func (r OnramperAPIOnRamperGetSupportedAssetsRequest) Country(country string) OnramperAPIOnRamperGetSupportedAssetsRequest {
	r.country = &country
	return r
}

func (r OnramperAPIOnRamperGetSupportedAssetsRequest) Execute() (*SupportedAssetResponse, *http.Response, error) {
	return r.ApiService.OnRamperGetSupportedAssetsExecute(r)
}

/*
OnRamperGetSupportedAssets Method for OnRamperGetSupportedAssets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetSupportedAssetsRequest
*/
func (a *OnramperAPIService) OnRamperGetSupportedAssets(ctx context.Context) OnramperAPIOnRamperGetSupportedAssetsRequest {
	return OnramperAPIOnRamperGetSupportedAssetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SupportedAssetResponse
func (a *OnramperAPIService) OnRamperGetSupportedAssetsExecute(r OnramperAPIOnRamperGetSupportedAssetsRequest) (*SupportedAssetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportedAssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetSupportedAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.source == nil {
		return localVarReturnValue, nil, reportError("source is required and must be specified")
	}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetSupportedCurrenciesRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	type_ *string
}

func (r OnramperAPIOnRamperGetSupportedCurrenciesRequest) Authorization(authorization string) OnramperAPIOnRamperGetSupportedCurrenciesRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetSupportedCurrenciesRequest) Type_(type_ string) OnramperAPIOnRamperGetSupportedCurrenciesRequest {
	r.type_ = &type_
	return r
}

func (r OnramperAPIOnRamperGetSupportedCurrenciesRequest) Execute() (*SupportedCurrenciesResponse, *http.Response, error) {
	return r.ApiService.OnRamperGetSupportedCurrenciesExecute(r)
}

/*
OnRamperGetSupportedCurrencies Method for OnRamperGetSupportedCurrencies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetSupportedCurrenciesRequest
*/
func (a *OnramperAPIService) OnRamperGetSupportedCurrencies(ctx context.Context) OnramperAPIOnRamperGetSupportedCurrenciesRequest {
	return OnramperAPIOnRamperGetSupportedCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SupportedCurrenciesResponse
func (a *OnramperAPIService) OnRamperGetSupportedCurrenciesExecute(r OnramperAPIOnRamperGetSupportedCurrenciesRequest) (*SupportedCurrenciesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportedCurrenciesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetSupportedCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetSupportedDefaultsAllRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	country *string
	type_ *string
}

func (r OnramperAPIOnRamperGetSupportedDefaultsAllRequest) Authorization(authorization string) OnramperAPIOnRamperGetSupportedDefaultsAllRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetSupportedDefaultsAllRequest) Country(country string) OnramperAPIOnRamperGetSupportedDefaultsAllRequest {
	r.country = &country
	return r
}

func (r OnramperAPIOnRamperGetSupportedDefaultsAllRequest) Type_(type_ string) OnramperAPIOnRamperGetSupportedDefaultsAllRequest {
	r.type_ = &type_
	return r
}

func (r OnramperAPIOnRamperGetSupportedDefaultsAllRequest) Execute() (*SupportedDefaultResponse, *http.Response, error) {
	return r.ApiService.OnRamperGetSupportedDefaultsAllExecute(r)
}

/*
OnRamperGetSupportedDefaultsAll Method for OnRamperGetSupportedDefaultsAll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetSupportedDefaultsAllRequest
*/
func (a *OnramperAPIService) OnRamperGetSupportedDefaultsAll(ctx context.Context) OnramperAPIOnRamperGetSupportedDefaultsAllRequest {
	return OnramperAPIOnRamperGetSupportedDefaultsAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SupportedDefaultResponse
func (a *OnramperAPIService) OnRamperGetSupportedDefaultsAllExecute(r OnramperAPIOnRamperGetSupportedDefaultsAllRequest) (*SupportedDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportedDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetSupportedDefaultsAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetSupportedOnRampsAllRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
}

func (r OnramperAPIOnRamperGetSupportedOnRampsAllRequest) Authorization(authorization string) OnramperAPIOnRamperGetSupportedOnRampsAllRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetSupportedOnRampsAllRequest) Execute() (*GetSupportedOnRampsResponse, *http.Response, error) {
	return r.ApiService.OnRamperGetSupportedOnRampsAllExecute(r)
}

/*
OnRamperGetSupportedOnRampsAll Method for OnRamperGetSupportedOnRampsAll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetSupportedOnRampsAllRequest
*/
func (a *OnramperAPIService) OnRamperGetSupportedOnRampsAll(ctx context.Context) OnramperAPIOnRamperGetSupportedOnRampsAllRequest {
	return OnramperAPIOnRamperGetSupportedOnRampsAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSupportedOnRampsResponse
func (a *OnramperAPIService) OnRamperGetSupportedOnRampsAllExecute(r OnramperAPIOnRamperGetSupportedOnRampsAllRequest) (*GetSupportedOnRampsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSupportedOnRampsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetSupportedOnRampsAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/onramps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetSupportedPaymentTypesRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	fiat *string
	country *string
	type_ *string
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) Authorization(authorization string) OnramperAPIOnRamperGetSupportedPaymentTypesRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) Fiat(fiat string) OnramperAPIOnRamperGetSupportedPaymentTypesRequest {
	r.fiat = &fiat
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) Country(country string) OnramperAPIOnRamperGetSupportedPaymentTypesRequest {
	r.country = &country
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) Type_(type_ string) OnramperAPIOnRamperGetSupportedPaymentTypesRequest {
	r.type_ = &type_
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) Execute() (*SupportedPaymentTypesCurrencyResponse, *http.Response, error) {
	return r.ApiService.OnRamperGetSupportedPaymentTypesExecute(r)
}

/*
OnRamperGetSupportedPaymentTypes Method for OnRamperGetSupportedPaymentTypes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetSupportedPaymentTypesRequest
*/
func (a *OnramperAPIService) OnRamperGetSupportedPaymentTypes(ctx context.Context) OnramperAPIOnRamperGetSupportedPaymentTypesRequest {
	return OnramperAPIOnRamperGetSupportedPaymentTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SupportedPaymentTypesCurrencyResponse
func (a *OnramperAPIService) OnRamperGetSupportedPaymentTypesExecute(r OnramperAPIOnRamperGetSupportedPaymentTypesRequest) (*SupportedPaymentTypesCurrencyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportedPaymentTypesCurrencyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetSupportedPaymentTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/payment-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.fiat == nil {
		return localVarReturnValue, nil, reportError("fiat is required and must be specified")
	}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fiat", r.fiat, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest struct {
	ctx context.Context
	ApiService OnramperAPI
	authorization *string
	fiat *string
	country *string
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest) Authorization(authorization string) OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest {
	r.authorization = &authorization
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest) Fiat(fiat string) OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest {
	r.fiat = &fiat
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest) Country(country string) OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest {
	r.country = &country
	return r
}

func (r OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest) Execute() (*SupportedPaymentTypesCurrencyResponse, *http.Response, error) {
	return r.ApiService.OnRamperGetSupportedPaymentTypesFiatExecute(r)
}

/*
OnRamperGetSupportedPaymentTypesFiat Method for OnRamperGetSupportedPaymentTypesFiat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest
*/
func (a *OnramperAPIService) OnRamperGetSupportedPaymentTypesFiat(ctx context.Context) OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest {
	return OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SupportedPaymentTypesCurrencyResponse
func (a *OnramperAPIService) OnRamperGetSupportedPaymentTypesFiatExecute(r OnramperAPIOnRamperGetSupportedPaymentTypesFiatRequest) (*SupportedPaymentTypesCurrencyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SupportedPaymentTypesCurrencyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnramperAPIService.OnRamperGetSupportedPaymentTypesFiat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/onramper/payment-types/fiat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.fiat == nil {
		return localVarReturnValue, nil, reportError("fiat is required and must be specified")
	}
	if r.country == nil {
		return localVarReturnValue, nil, reportError("country is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fiat", r.fiat, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
